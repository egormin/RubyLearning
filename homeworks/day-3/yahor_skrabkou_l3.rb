#!/usr/bin/env ruby

###################################################### 1 ######################################################
=begin
Hаписать метод, который принимает аргументом объект типа Proc и возвращает
время затраченное на выполнение данного прока(примитивный бенчмаркинг).
Текущее время можно узнать с помощью Time.now
=end

def benchmark(&block)
  time_before = Time.now
  p "result: #{block.call}"
  time_after = Time.now
  p "Time to processing: #{time_after - time_before} sec."
end

benchmark{(1..10000000).count{|val|val % 2 ==0}}

# RESULT:
#"result: 5000000"
#"Time to processing: 0.504860981"


###################################################### 2 ######################################################
=begin
дан массив: array = [1, 2, 3, 4]. Написать метод mega_sum, который поддерживает следующее использование:
mega_sum(array) # => 10 # простая сумма элементов
mega_sum(array, 10) # => 20 # сумма всёх элементов + переданное значение
mega_sum(array) { |i| i ** 2} => 30 # сумма элементов с применённым блоком
mega_sum(array, 10) { |i| i **2} => 40 # сумма элементов с применённым блоком + переданное значение
Это всё один метод!
=end

def mega_sum(a, b = 0)
  sum = 0
  (a.each{|e| sum += block_given?? yield(e):e})
  res = sum + b
end

array = [1, 2, 3, 4]
p mega_sum(array)                         # 10
p mega_sum(array, 10)                  # 20
p mega_sum(array){|i| i**2}               # 30
p mega_sum(array, 10){|i| i**2}        # 40

# RESULT:
# 10
# 20
# 30
# 40



###################################################### 3 ######################################################
=begin
В диапазоне от 1 до 1_000, найти первое трёхзначное число у которого остаток деления на 7 равен 3
=end

p (1..1000).detect{|val| (val % 7 == 3) && (val.to_s.size == 3)}

# RESULT:
# 101



###################################################### 4 ######################################################
=begin
Написать метод, с двумя именнованными аргументами, а всеми остальными не обязательными (не ограничено количеством).
Если за методом следует блок, то вызвать его на каждом из не обязательных аргументов, если же блок не следует
вывести ‘ERROR”.
Пример:
method_name(...) # => "ERROR"
method_name(..., 1, 2, 3) {|i| puts i}
=end

def my_meth(*other, a:, b:)
  block_given?? (other.each{|e| yield(e)}) : (p "ERROR")
end

my_meth(3, 4, 5, 6, a: 1,b: 2)                    # "ERROR"
my_meth(3, 4, 5,6, a: 1,b: 2){|i| puts i}

# RESULT:
# "ERROR"
# 3
# 4
# 5
# 6



###################################################### 5 ######################################################
=begin
Апгрейд стандартной библиотеки. Мы напишем метод, который будет возвращать все чётные числа,
соответсвующие переданному в блок условию:
Чтобы это работало, делаем так:
class Array
  def ваш_метод
    < code >
  end
end
=end




